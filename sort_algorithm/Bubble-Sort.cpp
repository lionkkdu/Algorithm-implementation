/*
冒泡排序重复地走访过要排序的元素，依次比较相邻两个元素，如果他们的顺序错误就把他们调换过来，直到没有元素再需要交换，排序完成。这个算法的名字由来是因为越小(或越大)的元素会经由交换慢慢“浮”到数列的顶端。

冒泡排序算法的运作如下：

比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
针对所有的元素重复以上的步骤，除了最后一个。
持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

尽管冒泡排序是最容易了解和实现的排序算法之一，但它对于少数元素之外的数列排序是很没有效率的
参考链接:https://www.cnblogs.com/eniac12/p/5329396.html
*/
void BubbleSort(int A[], int num)
{
    for (int i = 0; i < num - 1; ++i)
    {
        for (int j = 0; j < num - 1 - i; ++j)
        {
            if (A[j] > A[j + 1])    
                std::swap(A[j], A[j+1]);
        }
    }
}


int main()
{
    int A[] = { 6, 5, 3, 1, 8, 7, 2, 4 };    // 从小到大冒泡排序
    int n = sizeof(A) / sizeof(int);
    BubbleSort(A, n);
    cout << "冒泡排序结果：" << endl;
    for (int i = 0; i < n; i++)
    {
        printf("%d ", A[i]);
    }

    system("pause");
    return 0;
}
